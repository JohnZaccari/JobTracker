'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getImageDimensionsMacOSAsync = exports.createAndWriteIconsToPathAsync = undefined;

/**
 * Based on keys in the given manifest,
 * ensure that the proper iOS icon images exist -- assuming Info.plist already
 * points at them under CFBundleIcons.CFBundlePrimaryIcon.CFBundleIconFiles.
 *
 * This only works on MacOS (as far as I know) because it uses the sips utility.
 */
let createAndWriteIconsToPathAsync = (() => {
  var _ref = _asyncToGenerator(function* (manifest, destinationIconPath, projectRoot) {
    if (process.platform !== 'darwin') {
      console.warn('`sips` utility may or may not work outside of macOS');
    }
    let defaultIconFilename;
    if (manifest.ios && manifest.ios.iconUrl) {
      defaultIconFilename = 'exp-icon.png';
      yield (0, (_ExponentTools || _load_ExponentTools()).saveUrlToPathAsync)(manifest.ios.iconUrl, `${destinationIconPath}/${defaultIconFilename}`);
    } else if (manifest.iconUrl) {
      defaultIconFilename = 'exp-icon.png';
      yield (0, (_ExponentTools || _load_ExponentTools()).saveUrlToPathAsync)(manifest.iconUrl, `${destinationIconPath}/${defaultIconFilename}`);
    } else if (projectRoot && manifest.icon) {
      defaultIconFilename = 'exp-icon.png';
      yield (0, (_ExponentTools || _load_ExponentTools()).saveImageToPathAsync)(projectRoot, manifest.icon, `${destinationIconPath}/${defaultIconFilename}`);
    }

    let iconSizes = [20, 29, 40, 60, 76, 83.5, 1024];
    iconSizes.forEach(function (iconSize) {
      let iconResolutions;
      if (iconSize === 76) {
        // iPad has 1x and 2x icons for this size only
        iconResolutions = [1, 2];
      } else if (iconSize == 1024) {
        // marketing icon is weird
        iconResolutions = [1];
      } else {
        iconResolutions = [2, 3];
      }
      iconResolutions.forEach((() => {
        var _ref2 = _asyncToGenerator(function* (iconResolution) {
          let iconQualifier = _getAppleIconQualifier(iconSize, iconResolution);
          // TODO(nikki): Support local paths for these icons
          let iconKey = `iconUrl${iconQualifier}`;
          let rawIconFilename;
          let usesDefault = false;
          if (manifest.ios && manifest.ios.hasOwnProperty(iconKey)) {
            // manifest specifies an image just for this size/resolution, use that
            rawIconFilename = `exp-icon${iconQualifier}.png`;
            yield (0, (_ExponentTools || _load_ExponentTools()).saveUrlToPathAsync)(manifest.ios[iconKey], `${destinationIconPath}/${rawIconFilename}`);
          } else {
            // use default manifest.iconUrl
            usesDefault = true;
            if (defaultIconFilename) {
              rawIconFilename = defaultIconFilename;
            } else {
              console.warn(`Manifest does not specify ios.${iconKey} nor a default iconUrl. Bundle will use the Expo logo.`);
              return;
            }
          }

          let iconFilename = `AppIcon${iconQualifier}.png`;
          let iconSizePx = iconSize * iconResolution;
          // rewrite the color profile of the icon to the system profile
          // otherwise sips will barf when resizing for some images per
          // https://stackoverflow.com/questions/40316819/sips-shows-unable-to-render-destination-image
          // this is supposedly related to 16-bit vs. 8-bit color profiles but w/e
          try {
            yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('sips', ['--matchTo', '/System/Library/ColorSync/Profiles/sRGB Profile.icc', '--out', iconFilename, rawIconFilename], {
              stdio: ['ignore', 'ignore', 'ignore'],
              cwd: destinationIconPath
            });
          } catch (_) {
            // if sips color profile matching failed, still write the original file to
            // the destination path and try that, since the color thing isn't required
            // for most images.
            yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/cp', [rawIconFilename, iconFilename], {
              stdio: 'inherit',
              cwd: destinationIconPath
            });
          }
          yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('sips', ['-Z', iconSizePx, iconFilename], {
            stdio: ['ignore', 'ignore', 'inherit'], // only stderr
            cwd: destinationIconPath
          });

          // reject non-square icons (because Apple will if we don't)
          const dims = yield getImageDimensionsMacOSAsync(destinationIconPath, iconFilename);
          if (!dims || dims.length < 2 || dims[0] !== dims[1]) {
            throw new Error(`iOS icons must be square, the dimensions of ${iconFilename} are ${dims}`);
          }

          if (!usesDefault) {
            // non-default icon used, clean up the downloaded version
            yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/rm', [_path.default.join(destinationIconPath, rawIconFilename)]);
          }
        });

        return function (_x4) {
          return _ref2.apply(this, arguments);
        };
      })());
    });

    // clean up default icon
    if (defaultIconFilename) {
      yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/rm', [_path.default.join(destinationIconPath, defaultIconFilename)]);
    }
    return;
  });

  return function createAndWriteIconsToPathAsync(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
})();

/**
 *  @return array [ width, height ] or nil if that fails for some reason.
 */


let getImageDimensionsMacOSAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (dirname, basename) {
    if (process.platform !== 'darwin') {
      console.warn('`sips` utility may or may not work outside of macOS');
    }
    let childProcess = yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('sips', ['-g', 'pixelWidth', '-g', 'pixelHeight', basename], {
      cwd: dirname
    });
    let dimensions;
    try {
      // stdout looks something like 'pixelWidth: 1200\n pixelHeight: 800'
      const components = childProcess.stdout.split(/(\s+)/);
      dimensions = components.map(function (c) {
        return parseInt(c, 10);
      }).filter(function (n) {
        return !isNaN(n);
      });
    } catch (_) {}
    return dimensions;
  });

  return function getImageDimensionsMacOSAsync(_x5, _x6) {
    return _ref3.apply(this, arguments);
  };
})();

var _path = _interopRequireDefault(require('path'));

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = require('./ExponentTools');
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _getAppleIconQualifier(iconSize, iconResolution) {
  let iconQualifier;
  if (iconResolution !== 1) {
    // e.g. "29x29@3x"
    iconQualifier = `${iconSize}x${iconSize}@${iconResolution}x`;
  } else {
    iconQualifier = `${iconSize}x${iconSize}`;
  }
  if (iconSize === 76 || iconSize === 83.5) {
    // ipad sizes require ~ipad at the end
    iconQualifier = `${iconQualifier}~ipad`;
  }
  return iconQualifier;
}exports.createAndWriteIconsToPathAsync = createAndWriteIconsToPathAsync;
exports.getImageDimensionsMacOSAsync = getImageDimensionsMacOSAsync;
//# sourceMappingURL=../__sourcemaps__/detach/IosIcons.js.map
